{"version":3,"sources":["components/Header.js","components/Select.js","components/Orientations.js","components/Box.js","components/Board.js","utils.js","AlgorithmLib/BFS.js","AlgorithmLib/DFS.js","AlgorithmLib/A_star.js","AlgorithmLib/Dijkstras.js","AlgorithmLib/GreedyBFS.js","MazeLib/RecursiveBacktrack.js","MazeLib/Prims.js","Engine.js","components/Button.js","components/CheckBox.js","components/Controls.js","components/Settings.js","MazeLib/BlankMaze.js","MazeLib/InversePrims.js","App.js","reportWebVitals.js","index.js"],"names":["Header","className","Select","color","numOptions","values","texts","onChange","style","backgroundColor","evt","options","i","push","value","makeOptions","AlgorithmSelect","id","target","OrientationSelect","selected","number","defaultValue","defaultProps","Orientations","isMouseDown","Box","row","col","canDrawOn","toggleState","box","document","getElementById","hasBackgroundColor","setBackgroundColor","onMouseDown","e","preventDefault","handleMouseDown","onMouseUp","onMouseEnter","maxRow","maxCol","Board","cellSpacing","cellPadding","rows","cells","j","startPos","endPos","initBoard","defaultOrientation","colorToRGB","makeAllWhite","replace","toLowerCase","getAdjacent","startRow","startCol","soFar","orientationalJson","extraCheck","getKeyByValue","object","Object","keys","find","key","undefined","oriToRowCol","lst","coords","addToQueue","getFrontier","nextToVisited","visited","original","adjs","getRowFromId","getColFromId","orientationListToJson","length","includes","randNum","lower","range","Math","floor","random","orientationList","json","shuffle","array","randomIndex","currentIndex","index","num","charAt","parseInt","search","substring","getElementByPos","getBoxBetween","box1","box2","row1","col1","row2","col2","rowBetween","abs","min","colBetween","biasManhattan","targetBox","queue","prototype","toString","call","has","getAllBoxes","cols","BFSRun","endRow","endCol","marked","firstBox","path","shift","node","forEach","newPath","slice","DFSRun","DFSPath","DFSHelper","adjacents","pathCopy","console","log","AStarRelax","heuristic","distTo","stack","adj","newAdjDist","sort","path1","path2","A_star_run","relax","source","allBoxes","Infinity","DijkstrasRun","greedyRelax","GreedyRun","runRecursiveBacktrack","orientations","blackVisited","getAllBoxHorizontal","whiteVisited","randomDFS","currBox","validAdj","Engine","chosenAlg","isMaze","orientationOrdered","displayFancy","delay","this","chosenAlgorithm","engineIsRunning","algorithm","visitedColor","pathColor","a","queues","display","delayMS","sleep","overlapDisplay","displayAndOverlap","r","g","b","setTimeout","baseOverLayDelayMS","catchUpDelay","ms","Promise","resolve","pathDelayMS","Button","text","onClick","CheckBox","handleCheck","useState","isChecked","toggleCheck","type","for","Controls","blueClick","redClick","greenClick","checkClick","nameToAlgs","speedToDelayMS","nameToMaze","makePassage","passage","add","blocked","delete","splice","Set","start","frontiers","passageNeighbors","frontier","runRandomPrims","adjsFrontiers","frontierBox","betweenBox","runRandomInversePrims","Settings","blueFunc","redFunc","greenFunc","selectedAlg","setSelectedAlg","setOrientation","willDisplayFancy","toggleFancy","speed","setSpeed","maze","setMaze","alg","boxChecked","App","engine","setEngine","oriList","window","scrollTo","top","body","scrollHeight","behavior","isRunning","run","useEffect","newEngine","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.35753891.chunk.js","sourcesContent":["import React from 'react'\r\n\r\nconst Header = () => {\r\n    return (\r\n        <header className=\"header\">\r\n            <h1>Pathfind Visualizer</h1>\r\n        </header>\r\n    )\r\n}\r\n\r\n// CSS in JS\r\n// const headingStyle = {\r\n//     color: 'red',\r\n//     backgroundColor: 'black'\r\n// }\r\nexport default Header\r\n","import {React} from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\n\r\nexport const Select = ( { className, color, numOptions, values, texts, onChange} ) => {\r\n\r\n    function makeOptions() {\r\n        let options = [];\r\n        for (let i = 0; i < numOptions; i++) {\r\n            options.push(<option value={values[i]}>{texts[i]}</option>);\r\n        }\r\n        return options;\r\n    }\r\n\r\n    return (\r\n        <select className={className} style={{backgroundColor: color}}\r\n                onChange={(evt) => onChange(evt)} >\r\n            {makeOptions()}\r\n        </select>\r\n    )\r\n}\r\n\r\n\r\n\r\n\r\nexport const AlgorithmSelect = ( { color, onChange } ) => {\r\n\r\n\r\n    return (\r\n        <select className='alg-slct' id='algorithms' style={{backgroundColor: color}}\r\n            onChange={(evt) => onChange(evt.target.value)} >\r\n            <option value=\"DI\">Dijkstra's</option>\r\n            <option value=\"A*\">A* (Best First Search)</option>\r\n            <option value=\"DFS\">Depth First Search</option>\r\n            <option value=\"BFS\">Breadth First Search</option>\r\n            <option value=\"GREEDY\">Greedy Best First Search</option>\r\n        </select>\r\n    )\r\n}\r\n\r\nexport const OrientationSelect = ( { color, selected, number, onChange } ) => {\r\n    \r\n    return (\r\n        <select className='ori-slct' id={`orientation-${number}`} style={{backgroundColor: color}} \r\n            defaultValue={selected} onChange={(evt) => onChange(evt, number)}>\r\n            <option value=\"N\">North</option>\r\n            <option value=\"E\">East</option>\r\n            <option value=\"S\">South</option>\r\n            <option value=\"W\">West</option>\r\n        </select>\r\n    )\r\n}\r\n\r\nAlgorithmSelect.defaultProps = {\r\n    color: 'black'\r\n}\r\n","import React from 'react';\r\nimport {OrientationSelect} from './Select';\r\n\r\nconst Orientations = ({onChange}) => {\r\n    return (\r\n        <span className=\"orientations\">\r\n            <span className=\"circle-number\">1</span>\r\n            <OrientationSelect color=\"#008080\" selected=\"N\" number='1' onChange={onChange} />\r\n            <span className=\"circle-number\">2</span>\r\n            <OrientationSelect color=\"#008080\" selected=\"E\" number='2' onChange={onChange} />\r\n            <span className=\"circle-number\">3</span>\r\n            <OrientationSelect color=\"#008080\" selected=\"S\" number='3' onChange={onChange} />\r\n            <span className=\"circle-number\">4</span>\r\n            <OrientationSelect color=\"#008080\" selected=\"W\" number='4' onChange={onChange} />  \r\n        </span>\r\n    )\r\n}\r\n\r\nexport default Orientations;\r\n","import {React, useState} from 'react';\r\nimport {hasBackgroundColor, setBackgroundColor} from '../utils';\r\n\r\nvar isMouseDown = false;\r\nconst Box = ({row, col, color, canDrawOn}) => {\r\n\r\n    var handleMouseDown = (e) => {\r\n        e.preventDefault();\r\n        if (canDrawOn()) {\r\n            isMouseDown = true;\r\n            toggleState();\r\n        }\r\n    }\r\n\r\n    var handleMouseUp = (e) => {\r\n        isMouseDown = false;\r\n    }\r\n\r\n    var toggleState = () => {\r\n        let box = document.getElementById(`${row}-${col}`)\r\n        if (hasBackgroundColor(box, \"white\")) {\r\n            setBackgroundColor(box, \"black\");\r\n        } else if (hasBackgroundColor(box, \"black\")) {\r\n            setBackgroundColor(box, \"white\");\r\n        }\r\n    }\r\n\r\n    return (\r\n        <td \r\n            className=\"box\" \r\n            id={row + \"-\" + col}\r\n            style={{backgroundColor: color}} \r\n            onMouseDown={ (e) => handleMouseDown(e) }   \r\n            onMouseUp={ (e) =>  handleMouseUp(e) }\r\n            onMouseEnter={ (e) => { if (isMouseDown) toggleState(); } }\r\n            >\r\n        </td>\r\n    )\r\n}\r\n\r\nBox.defaultProps = {\r\n    color: 'white',\r\n    canDrawOn: function(e) { e.preventDefault(); return false; }\r\n}\r\n\r\nexport default Box\r\n","import React from 'react';\r\nimport Box from './Box';\r\nimport {startPos, endPos, startingIcon} from './Settings';\r\n\r\nexport const maxRow = 20;\r\nexport const maxCol = 55;\r\n\r\n\r\nconst Board = ( { canDrawOn } ) => {\r\n\r\n    function initBoard() {\r\n        let rows = [];\r\n        for(var i = 0; i < maxRow + 1; i++) {\r\n            let cells = [];\r\n            for(var j = 0; j < maxCol + 1; j++) {\r\n                if (i === startPos[0] && j === startPos[1]) {\r\n                    cells.push(<Box row={i} col={j} color=\"green\"/>);\r\n                } else if (i === endPos[0] && j === endPos[1]) {\r\n                    cells.push(<Box row={i} col={j} color=\"red\" />);\r\n                } else {\r\n                    cells.push(<Box row={i} col={j} canDrawOn={canDrawOn} />);\r\n                }\r\n            }\r\n            rows.push(<tr>{cells}</tr>);\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    return (\r\n        <table className=\"board\" cellSpacing=\"0\" cellPadding=\"0\">\r\n            <tbody>\r\n                {initBoard()}\r\n            </tbody>\r\n        </table>\r\n    )\r\n}\r\n\r\n\r\n\r\n\r\nexport default Board;\r\n","import {maxRow, maxCol} from './components/Board';\r\nimport { startPos, endPos } from './components/Settings';\r\n\r\nvar numOrientations = 4;\r\nvar defaultOrientation = {\r\n    'N': 1,\r\n    'E': 2,\r\n    'S': 3,\r\n    'W': 4\r\n}\r\n\r\nconst colorToRGB = {\r\n    \"black\": \"rgb(0, 0, 0)\",\r\n    \"white\": \"rgb(255, 255, 255)\"\r\n}\r\n\r\nexport function makeAllWhite() {\r\n    for (let row = 0; row <= maxRow; row++) {\r\n        for (let col = 0; col <= maxCol; col++) {\r\n            let box = document.getElementById(`${row}-${col}`);\r\n            if (row === startPos[0] && col === startPos[1]) {\r\n                setBackgroundColor(box, \"green\");\r\n            } else if (row === endPos[0] && col === endPos[1]) {\r\n                setBackgroundColor(box, \"red\");\r\n            } else {\r\n                setBackgroundColor(box, \"white\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function isWall(box) {\r\n    return hasBackgroundColor(box, \"black\");\r\n}\r\n\r\nexport function isPassage(box) {\r\n    return hasBackgroundColor(box, \"white\");\r\n}\r\n\r\nexport function hasBackgroundColor(box, color) {\r\n    color = color.replace(/\\s+/g,'').toLowerCase();\r\n    return box.style.backgroundColor === color || box.style.backgroundColor === colorToRGB[color];\r\n}\r\n\r\nexport function setBackgroundColor(box, color) {\r\n    box.style.backgroundColor = color;\r\n}\r\n\r\nexport function getAdjacent(startRow, startCol, soFar, orientationalJson, extraCheck) {\r\n    /* Orientation:\r\n            A\r\n        D start B\r\n            C\r\n    A -> B -> C -> D\r\n    */\r\n   /* If invalid orientation, then orientation is NESW */\r\n   /* extraCond */\r\n    if (orientationalJson === undefined) {\r\n        orientationalJson = defaultOrientation;\r\n    }\r\n\r\n    extraCheck === undefined ? extraCheck = (box) => { return true; } : extraCheck = extraCheck;\r\n\r\n   function getKeyByValue(object, value) {\r\n    return Object.keys(object).find(key => object[key] === value);\r\n    }\r\n  \r\n    var oriToRowCol = {\r\n        'N': [startRow - 1, startCol],\r\n        'E': [startRow, startCol + 1],\r\n        'S': [startRow + 1, startCol],\r\n        'W': [startRow, startCol - 1]\r\n    }\r\n    let lst = [];\r\n    for (let i = 1; i <= numOrientations; i++) {\r\n        let ori = getKeyByValue(orientationalJson, i);\r\n        let coords = oriToRowCol[ori];\r\n        addToQueue(lst, coords[0], coords[1], soFar, extraCheck);\r\n    }\r\n    return lst;\r\n}\r\n\r\nexport function getFrontier(startRow, startCol, soFar, orientationalJson, extraCheck) {\r\n    /* Orientation:\r\n            A\r\n        D start B\r\n            C\r\n    A -> B -> C -> D\r\n    */\r\n   /* If invalid orientation, then orientation is NESW */\r\n   /* extraCond */\r\n    if (orientationalJson === undefined) {\r\n        orientationalJson = defaultOrientation;\r\n    }\r\n\r\n    extraCheck === undefined ? extraCheck = (box) => { return true; } : extraCheck = extraCheck;\r\n\r\n   function getKeyByValue(object, value) {\r\n    return Object.keys(object).find(key => object[key] === value);\r\n    }\r\n  \r\n    var oriToRowCol = {\r\n        'N': [startRow - 2, startCol],\r\n        'E': [startRow, startCol + 2],\r\n        'S': [startRow + 2, startCol],\r\n        'W': [startRow, startCol - 2]\r\n    }\r\n    let lst = [];\r\n    for (let i = 1; i <= numOrientations; i++) {\r\n        let ori = getKeyByValue(orientationalJson, i);\r\n        let coords = oriToRowCol[ori];\r\n        addToQueue(lst, coords[0], coords[1], soFar, extraCheck);\r\n    }\r\n    return lst;\r\n}\r\n\r\n\r\nexport function getAdjacentAllRound(startRow, startCol, soFar, extraCheck) {\r\n    extraCheck === undefined ? extraCheck = (box) => { return true; } : extraCheck = extraCheck;\r\n\r\n    let adjs = [[startRow - 1, startCol], \r\n               [startRow, startCol + 1], \r\n               [startRow + 1, startCol], \r\n               [startRow, startCol - 1],\r\n               [startRow - 1, startCol - 1],\r\n               [startRow - 1, startCol + 1],\r\n               [startRow + 1, startCol - 1],\r\n               [startRow + 1, startCol + 1]\r\n            ];\r\n    let lst = [];\r\n    for (let i = 0; i < adjs.length; i++) {\r\n        let coords = adjs[i];\r\n        addToQueue(lst, coords[0], coords[1], soFar, extraCheck);\r\n    }\r\n    return lst;\r\n}\r\n\r\n\r\nexport function nextToVisited(box, visited, original) {\r\n    let row = getRowFromId(box.id);\r\n    let col = getColFromId(box.id);\r\n    let adjs = getAdjacent(row, col, [], orientationListToJson(['N', 'E', 'S', 'W']));\r\n    for (let i = 0; i < adjs.length; i++) {\r\n        if (visited.includes(adjs[i]) && adjs[i] != original) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function randNum(lower, range) {\r\n    return Math.floor((Math.random() * range) + lower);\r\n}\r\n\r\nexport function orientationListToJson(orientationList) {\r\n    let json = []\r\n    for (let i = 1; i <= orientationList.length; i++) {\r\n        json[orientationList[i - 1]] = i;\r\n    }\r\n    if (Object.keys(json).length < numOrientations) {\r\n        return defaultOrientation;\r\n    } else {\r\n        return json;\r\n    }\r\n}\r\n\r\n\r\nexport function shuffle(array) {\r\n    var currentIndex = array.length, randomIndex;\r\n\r\n    // While there remain elements to shuffle...\r\n    while (0 !== currentIndex) {\r\n\r\n        // Pick a remaining element...\r\n        randomIndex = Math.floor(Math.random() * currentIndex);\r\n        currentIndex--;\r\n\r\n        // And swap it with the current element.\r\n        [array[currentIndex], array[randomIndex]] = [\r\n        array[randomIndex], array[currentIndex]];\r\n    }\r\n\r\n    return array;\r\n}\r\n\r\n\r\nexport function getRowFromId(id) {\r\n    let index = 0;\r\n    let num = '';\r\n    while (id.charAt(index) != '-') {\r\n        num += id.charAt(index);\r\n        index++;\r\n    }\r\n    return parseInt(num);\r\n}\r\n\r\n\r\nexport function getColFromId(id) {\r\n    let index = id.search('-');\r\n    return parseInt(id.substring(index + 1));\r\n}\r\n\r\nexport function getElementByPos(row, col) {\r\n    return document.getElementById(`${row}-${col}`); \r\n}\r\n\r\nexport function getBoxBetween(box1, box2) {\r\n    let row1 = getRowFromId(box1.id);\r\n    let col1 = getColFromId(box1.id);\r\n    let row2 = getRowFromId(box2.id);\r\n    let col2 = getColFromId(box2.id);\r\n    let rowBetween = Math.floor(Math.abs(row1 - row2) / 2) + Math.min(row1, row2);\r\n    let colBetween = Math.floor(Math.abs(col1 - col2) / 2) + Math.min(col1, col2);\r\n    if (rowBetween >= 0 && rowBetween <= maxRow && colBetween >= 0 && colBetween <= maxCol) {\r\n        return getElementByPos(rowBetween, colBetween);\r\n    }\r\n    return null;\r\n}\r\n\r\n// TODO: try weight stuff\r\nexport function getDist(box1, box2) {\r\n    if (distBetweenBoxes(box1, box2) != 1) {\r\n        return null; // not connected\r\n    }\r\n    return 1;\r\n}\r\n\r\n/* Bias in wanting puts more weight on difference in rows */\r\nexport function biasManhattan(box, targetBox) {\r\n    let row1 = getRowFromId(box.id);\r\n    let col1 = getColFromId(box.id);\r\n    let row2 = getRowFromId(targetBox.id);\r\n    let col2 = getColFromId(targetBox.id);\r\n    return 2*(Math.abs(col2 - col1) + 5*Math.abs(row2 - row1)); \r\n    // scaled by 3 for better results\r\n}\r\n\r\n\r\nexport function distBetweenIds(id1, id2) {\r\n    let row1 = getRowFromId(id1);\r\n    let col1 = getColFromId(id1);\r\n    let row2 = getRowFromId(id2);\r\n    let col2 = getColFromId(id2);\r\n    return Math.sqrt((row1 - row2)**2 + (col1 - col2)**2);\r\n}\r\n\r\n\r\nexport function distBetweenBoxes(box1, box2) {\r\n    let id1 = box1.id;\r\n    let id2 = box2.id;\r\n    let row1 = getRowFromId(id1);\r\n    let col1 = getColFromId(id1);\r\n    let row2 = getRowFromId(id2);\r\n    let col2 = getColFromId(id2);\r\n    return Math.sqrt((row1 - row2)**2 + (col1 - col2)**2);\r\n}\r\n\r\n\r\nfunction addToQueue(queue, row, col, soFar, extraCheck) {\r\n    if (row < 0 || row > maxRow) { return; }\r\n    if (col < 0 || col > maxCol) { return; }\r\n    let box = getElementByPos(row, col);\r\n    if (Object.prototype.toString.call(soFar) === \"[object Set]\") {\r\n        if (!soFar.has(box) && !hasBackgroundColor(box, \"black\") && extraCheck(box)) {\r\n            queue.push(box);\r\n        }\r\n    } else if (!soFar.includes(box) && !hasBackgroundColor(box, \"black\") && extraCheck(box)) {\r\n        queue.push(box);\r\n    }\r\n}\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\n/* Also in Engine class */\r\nexport async function display(queue, path) {\r\n    let ms = 0;\r\n    let r = 64\r\n    let g = 224;\r\n    let b = 208\r\n    for (let i = 0; i < queue.length; i++) {\r\n        if (hasBackgroundColor(queue[i], \"white\")) {  // don't override green or red\r\n            setBackgroundColor(queue[i], `rgb(${r}, ${g}, ${b})`);\r\n            setTimeout(function () { overlapDisplay(queue[i], r - 1, g - 3, b - 3); }, 500);\r\n        }\r\n        await sleep(ms);\r\n    }\r\n    let pathMS = 20;\r\n    for (let i = 0; i < path.length; i++) {\r\n        setBackgroundColor(path[i], \"yellow\");\r\n        await sleep(pathMS);\r\n    }\r\n    console.log('Displayed');\r\n}\r\n\r\n\r\n/* rgb(64, 187, 224), rgb(56, 164, 197), rgb(48, 134, 160), rgb(48, 106, 160); */\r\nasync function overlapDisplay(box, r, g, b) {\r\n    if (r < 20 || g <= 50 || b <= 50 || hasBackgroundColor(box, \"yellow\")) {\r\n        return;\r\n    }\r\n    box.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;\r\n    await sleep(100);\r\n    await overlapDisplay(box, r - 2, g - 6, b - 6);\r\n}\r\n\r\nexport function getAllBoxes() {\r\n    let rows = [];\r\n    for (let row = 0; row <= maxRow; row++) {\r\n        let cols = []\r\n        for (let col = 0; col <= maxCol; col++) {\r\n            cols.push(document.getElementById(`${row}-${col}`));\r\n        }\r\n        rows.push(cols);\r\n    }\r\n    return rows;\r\n} \r\n\r\n/* Deprecated MinHeap, maybe will be used later\r\nexport class MinHeap {\r\n    constructor(boxes, sourceBox) {\r\n        this.arrayRep = [null]; // 0th position is sentinel\r\n        this.sourceBox = sourceBox;\r\n        boxes.forEach(box => {\r\n            let node = new Node(box, sourceBox);\r\n            if (node === sourceBox) {\r\n                this.arrayRep = [null, node].concat(this.arrayRep.subarray(1, this.arrayRep.length));\r\n            }\r\n            this.addNode(new Node(box, sourceBox));\r\n        });\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.arrayRep.length < 2;\r\n    }\r\n\r\n    compareNodes(node1, node2) {\r\n        return node1.distTo - node2.distTo;\r\n    }\r\n\r\n    parentIndex(index) {\r\n        return parseInt(index / 2);\r\n    }\r\n\r\n    parent(index) {\r\n        return this.parentIndex(index) < 1 ? \r\n                null : this.arrayRep[this.parentIndex(index)];\r\n    }\r\n\r\n    rightChildIndex(index) {\r\n        return index * 2 + 1;\r\n    }\r\n\r\n    rightChild(index) {\r\n        return index * 2 + 1 >= this.arrayRep.length ? \r\n                null : this.arrayRep[this.rightChildIndex(index)];\r\n    }\r\n\r\n    leftChildIndex(index) {\r\n        return index * 2;\r\n    }\r\n\r\n    leftChild(index) {\r\n        return index * 2 >= this.arrayRep.length ? \r\n                null : this.arrayRep[this.leftChildIndex(index)];\r\n    }\r\n\r\n    // Node added to end of arrayRep, swims up //\r\n    addNode(node) {\r\n        this.arrayRep.push(node);\r\n        let k = this.arrayRep.length - 1;\r\n        while (this.parent(k) \r\n                && this.compareNodes(this.parent(k), node) > 0) { // node has lower distTo\r\n            let newIndex = this.parentIndex(k);\r\n            let prevParent = this.parent(k);\r\n            this.arrayRep[newIndex] = node;\r\n            this.arrayRep[k] = prevParent;\r\n            k = newIndex;\r\n        }\r\n    }\r\n\r\n    addBox(box) {\r\n        let node = new Node(box, this.sourceBox);\r\n        this.addNode(node);\r\n    }\r\n\r\n    popSmallest() {\r\n        if (!this.isEmpty) {\r\n            let smallest = this.arrayRep[1];\r\n            this.arrayRep[1] = this.arrayRep[this.arrayRep.length - 1];\r\n            this.arrayRep.pop();\r\n            this.sink(1);\r\n            return smallest;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    sink(index) {\r\n        let node = this.arrayRep[index];\r\n        let leftIndex = this.leftChildIndex(index);\r\n        let rightIndex = this.rightChildIndex(index);\r\n        let left = this.leftChild(index);\r\n        let right = this.rightChild(index)\r\n        if (left && right) {\r\n            if (this.compareNodes(node, left) <= 0 && this.compareNodes(node, right) <= 0) {\r\n                return;\r\n            }\r\n            let cp = this.compareNodes(left, right);\r\n            if (cp <= 0) {\r\n                // sink to the left\r\n                this.arrayRep[leftIndex] = node;\r\n                this.arrayRep[index] = left;\r\n                this.sink(leftIndex);\r\n            } else {\r\n                // sink to the right\r\n                this.arrayRep[rightIndex] = node;\r\n                this.arrayRep[index] = right;\r\n                this.sink(rightIndex);\r\n            }\r\n        } else if (left) {\r\n            let cp = this.compareNodes(node, left);\r\n            if (cp <= 0) {\r\n                return;\r\n            } else {\r\n                // sink to the left\r\n                this.arrayRep[leftIndex] = node;\r\n                this.arrayRep[index] = left;\r\n                this.sink(leftIndex);\r\n            }\r\n        } else if (right) {\r\n            let cp = this.compareNodes(node, right);\r\n            if (cp <= 0) {\r\n                return;\r\n            } else {\r\n                // sink to the left\r\n                this.arrayRep[rightIndex] = node;\r\n                this.arrayRep[index] = right;\r\n                this.sink(rightIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport class Node {\r\n    constructor(box, sourceBox) {\r\n        this.box = box;\r\n        this.sourceBox = sourceBox;\r\n        this.distTo = box === sourceBox ? 0 :Infinity;\r\n    }\r\n}\r\n\r\n*/\r\n","import {getAdjacent, getRowFromId, getColFromId, getElementByPos, display} from '../utils';\r\n\r\nfunction BFSRun(startRow, startCol, endRow, endCol, orientationList) {\r\n    let queue = [];\r\n    let marked = []; // marked will include boxes from scouting adjacents (for performance)\r\n    let visited = []; // visited will not include boxes from scouting adjacents\r\n                     // (so that BFS will stop and not look at adjacents at last node)\r\n    let firstBox = getElementByPos(startRow, startCol)\r\n    queue.push([firstBox]);\r\n    marked.push(firstBox);\r\n    while (queue.length != 0) {\r\n        let path = queue[0];\r\n        queue.shift();\r\n        let node = path[path.length - 1];\r\n        visited.push(node);\r\n        startRow = getRowFromId(node.id);\r\n        startCol = getColFromId(node.id);\r\n        if (startRow === endRow && startCol === endCol) {\r\n            return {\"visited\": visited, \"path\": path};\r\n        }\r\n        let adjacents = getAdjacent(startRow, startCol, marked, orientationList);\r\n        adjacents.forEach(box => {\r\n            let newPath = path.slice();\r\n            newPath.push(box);\r\n            queue.push(newPath);\r\n            marked.push(box);\r\n        });\r\n    }\r\n    return {\"visited\": visited, \"path\": []};\r\n}\r\n\r\nexport default BFSRun;","import {getAdjacent, getRowFromId, getColFromId, getElementByPos} from '../utils';\r\n\r\n\r\nfunction DFSRun(startRow, startCol, endRow, endCol, orientationalJson) {\r\n    var visited = [];\r\n    function DFSHelper(startRow, startCol, endRow, endCol, path, orientationalJson) {\r\n        let node = getElementByPos(startRow, startCol)\r\n        visited.push(node);\r\n        path.push(node);\r\n        if (startRow === endRow && startCol === endCol) { return path; }\r\n        let adjacents = getAdjacent(startRow, startCol, visited, orientationalJson);\r\n        if (!adjacents.length) { return null; }\r\n        for (let i = 0; i < adjacents.length; i++) { // return in for each doesn't end the loop...\r\n            if (visited.includes(adjacents[i])) {\r\n                continue;\r\n            }\r\n            let pathCopy = path.slice();\r\n            let row = getRowFromId(adjacents[i].id);\r\n            let col = getColFromId(adjacents[i].id);\r\n            let newPath = DFSHelper(row, col, endRow, endCol, pathCopy, orientationalJson);\r\n            if (newPath) {\r\n                return newPath;\r\n            }\r\n        };\r\n    }\r\n    let DFSPath = DFSHelper(startRow, startCol, endRow, endCol, [], orientationalJson);\r\n    console.log(visited);\r\n    if (DFSPath) {\r\n        return {\"visited\": visited, \"path\": DFSPath};\r\n    }\r\n    return {\"visited\": visited, \"path\": []};\r\n}\r\n\r\nexport default DFSRun;","import {getAdjacent, getRowFromId, getColFromId, getElementByPos, display,\r\n        getAllBoxes, biasManhattan} from '../utils';\r\n\r\n\r\nfunction A_star_run(startRow, startCol, endRow, endCol, \r\n        orientationalJson, heuristic=biasManhattan, relax=AStarRelax) {\r\n    var visited = []\r\n    var distTo = {}\r\n    // var edgeTo = {} // may not be necessary\r\n    var stack = []\r\n    var source = getElementByPos(startRow, startCol);\r\n    var target = getElementByPos(endRow, endCol);\r\n    let allBoxes = getAllBoxes();\r\n    for (let row = 0; row < allBoxes.length; row++) {\r\n        for (let col = 0; col < allBoxes[0].length; col++) {\r\n            distTo[allBoxes[row][col].id] = Infinity;\r\n            // edgeTo[allBoxes[row][col].id] = null;\r\n        }\r\n    }\r\n    stack.push([source]);\r\n    distTo[source.id] = 0;\r\n    // edgeTo[source.id] = null;\r\n    while (stack.length != 0) {\r\n        let path = stack[0];\r\n        stack.shift();\r\n        let box = path[path.length - 1];\r\n        if (visited.includes(box)) {\r\n            continue;\r\n        }\r\n        visited.push(box);\r\n        if (getRowFromId(box.id) === endRow && getColFromId(box.id) === endCol) {\r\n            return {\"visited\": visited, \"path\": path};\r\n        }\r\n        relax(box, path, heuristic, target, orientationalJson, visited, distTo, stack);\r\n    }\r\n    return {\"visited\": visited, \"path\": []};\r\n}\r\n\r\n\r\nfunction AStarRelax(box, path, heuristic, target, orientationalJson, visited, distTo, stack) {\r\n    let adjacents = getAdjacent(getRowFromId(box.id), getColFromId(box.id), visited, orientationalJson);\r\n    adjacents.forEach(adj => {\r\n        let pathCopy = path.slice();\r\n        let newAdjDist = 1 + distTo[box.id] + heuristic(adj, target);\r\n        let oldAdjDist = distTo[adj.id];\r\n        if (newAdjDist < oldAdjDist) {\r\n            distTo[adj.id] = newAdjDist;\r\n            // edgeTo[adj.id] = box.id;\r\n        }\r\n        pathCopy.push(adj);\r\n        stack.push(pathCopy);\r\n    });\r\n    if (adjacents) {\r\n        stack.sort(function(path1, path2) {\r\n            return distTo[path1[path1.length - 1].id] - distTo[path2[path2.length - 1].id];\r\n        });\r\n    } \r\n}\r\n\r\nexport default A_star_run;","import A_star_run from './A_star'\r\n\r\nfunction DijkstrasRun(startRow, startCol, endRow, endCol, orientationList) {\r\n    return A_star_run(startRow, startCol, endRow, endCol, orientationList, heuristic);\r\n}\r\n\r\nvar heuristic = (box1, box2) => { return 0; };\r\n\r\nexport default DijkstrasRun;","import A_star_run from './A_star';\r\nimport {getAdjacent, getRowFromId, getColFromId} from '../utils';\r\n\r\nfunction GreedyRun(startRow, startCol, endRow, endCol, orientationList) {\r\n    return A_star_run(startRow, startCol, endRow, endCol, orientationList, undefined, greedyRelax);\r\n}\r\n\r\nconst greedyRelax = (box, path, heuristic, target, orientationalJson, visited, distTo, stack) => {\r\n    let adjacents = getAdjacent(getRowFromId(box.id), getColFromId(box.id), visited, orientationalJson);\r\n    adjacents.forEach(adj => {\r\n        let pathCopy = path.slice();\r\n        let newAdjDist = heuristic(adj, target);\r\n        let oldAdjDist = distTo[adj.id];\r\n        if (newAdjDist < oldAdjDist) {\r\n            distTo[adj.id] = newAdjDist;\r\n            // edgeTo[adj.id] = box.id;\r\n        }\r\n        pathCopy.push(adj);\r\n        stack.push(pathCopy);\r\n    });\r\n    if (adjacents) {\r\n        stack.sort(function(path1, path2) {\r\n            return distTo[path1[path1.length - 1].id] - distTo[path2[path2.length - 1].id];\r\n        });\r\n    } \r\n}\r\n\r\nexport default GreedyRun;","import { FaMarker } from 'react-icons/fa';\r\nimport {maxRow, maxCol} from '../components/Board';\r\nimport {getAdjacent, nextToVisited, getRowFromId, getColFromId, getElementByPos, \r\n        shuffle, orientationListToJson, makeAllWhite} from '../utils';\r\nimport {defaultOrientation} from '../components/Settings';\r\n\r\nexport default function runRecursiveBacktrack(startRow, startCol) {\r\n    makeAllWhite();\r\n    var orientations = defaultOrientation;\r\n    var blackVisited = getAllBoxHorizontal(); // turn all black\r\n    function randomDFS(startRow, startCol, visited) {\r\n        shuffle(orientations);\r\n        let currBox = getElementByPos(startRow, startCol);\r\n        visited.push(currBox);\r\n        let validAdj = getAdjacent(startRow, startCol, visited, orientationListToJson(orientations), \r\n            (box) => { return !nextToVisited(box, visited, currBox); });\r\n        for (let i = 0; i < validAdj.length; i++) {\r\n            if (!nextToVisited(validAdj[i], visited, currBox)) {\r\n                randomDFS(getRowFromId(validAdj[i].id), getColFromId(validAdj[i].id), visited);\r\n            }   \r\n        }\r\n    }\r\n    let whiteVisited = [];\r\n    randomDFS(startRow, startCol, whiteVisited);  // turn white path\r\n    return {\"visited\": blackVisited, \"path\": whiteVisited}\r\n}\r\n\r\nfunction getAllBoxHorizontal() {\r\n    let lst = []\r\n    for (let row = 0; row <= maxRow; row++) {\r\n        for (let col = 0; col <= maxCol; col++) {\r\n            lst.push(document.getElementById(`${row}-${col}`));\r\n        }\r\n    }\r\n    return lst;\r\n}","import {getAdjacent, getRowFromId, getColFromId, getElementByPos,\r\n    getAllBoxes, shuffle, orientationListToJson, nextToVisited, getFrontier, randNum, getBoxBetween, makeAllWhite} from '../utils';\r\nimport { maxRow, maxCol } from '../components/Board';\r\nimport { defaultOrientation } from '../components/Settings';\r\n\r\n\r\nexport default function runRandomPrims(startRow, startCol) {\r\n\r\n    makeAllWhite();\r\n\r\n    function isBlocked(box) {\r\n        return blocked.has(box);\r\n    }\r\n\r\n    function makePassage(box) {\r\n        if (!whiteVisited.includes(box)) {\r\n            whiteVisited.push(box);\r\n        }\r\n        passage.add(box);\r\n        blocked.delete(box);\r\n    }\r\n\r\n    var orientations = defaultOrientation.splice();\r\n    var blocked = new Set(getAllBoxHorizontal());\r\n    var passage = new Set();\r\n    let blackVisited = getAllBoxHorizontal();\r\n    let start = getElementByPos(startRow, startCol);\r\n    let whiteVisited = [start];\r\n    let frontiers = getFrontier(startRow, startCol, passage, \r\n        orientationListToJson(orientations));\r\n    makePassage(start);\r\n    while (frontiers.length > 0) {\r\n        shuffle(orientations);\r\n        let index = randNum(0, frontiers.length);\r\n        let currBox = frontiers[index];\r\n        startRow = getRowFromId(currBox.id);\r\n        startCol = getColFromId(currBox.id);\r\n        let passageNeighbors = getFrontier(startRow, startCol, blocked, \r\n            orientationListToJson(orientations));\r\n        if (passageNeighbors.length > 0) {\r\n            let oldFrontierBox = passageNeighbors[0];\r\n            let betweenBox = getBoxBetween(oldFrontierBox, currBox);\r\n            makePassage(betweenBox);\r\n            makePassage(currBox);\r\n        }\r\n        let newFrontiers = getFrontier(startRow, startCol, passage, \r\n            orientationListToJson(orientations));\r\n        newFrontiers.forEach((frontier) => {\r\n            frontiers.push(frontier);\r\n        });\r\n        frontiers.splice(index, 1);\r\n    }\r\n    return {\"visited\": blackVisited, \"path\": whiteVisited};\r\n}\r\n\r\n\r\nfunction getAllBoxHorizontal() {\r\n    let lst = []\r\n    for (let row = 0; row <= maxRow; row++) {\r\n        for (let col = 0; col <= maxCol; col++) {\r\n            lst.push(document.getElementById(`${row}-${col}`));\r\n        }\r\n    }\r\n    return lst;\r\n}\r\n","import BFSRun from './AlgorithmLib/BFS';\r\nimport DFSRun from './AlgorithmLib/DFS';\r\nimport DijkstrasRun from './AlgorithmLib/Dijkstras';\r\nimport A_star_run from './AlgorithmLib/A_star';\r\nimport GreedyRun from './AlgorithmLib/GreedyBFS';\r\nimport {setBackgroundColor, hasBackgroundColor, orientationListToJson} from './utils';\r\nimport runBlankMaze from './MazeLib/BlankMaze';\r\nimport runRecursiveBacktrack from './MazeLib/RecursiveBacktrack';\r\nimport runRandomPrims from './MazeLib/Prims';\r\nimport runRandomInversePrims from './MazeLib/InversePrims';\r\n\r\n\r\nexport class Engine { \r\n\r\n    constructor(chosenAlg, isMaze, startRow, startCol, endRow, endCol, \r\n                        orientationOrdered, displayFancy, delay) {\r\n        this.chosenAlgorithm = chosenAlg;\r\n        this.isMaze = isMaze;\r\n        this.startRow = startRow;\r\n        this.startCol = startCol;\r\n        this.endRow = endRow;\r\n        this.endCol = endCol;\r\n        this.orientationOrdered = orientationOrdered;\r\n        this.displayFancy = displayFancy;\r\n        this.engineIsRunning = false;\r\n        this.delay = delay;\r\n        this.algorithm = () => {\r\n            return chosenAlg(startRow, startCol, endRow, endCol, orientationOrdered);\r\n        }\r\n        if (!isMaze) {\r\n            this.visitedColor = {'r': 64, 'g': 224, 'b': 208};\r\n            this.pathColor = \"yellow\";\r\n        } else {\r\n            this.visitedColor = {'r': 0, 'g': 0, 'b': 0};\r\n            this.pathColor = \"white\";\r\n        }\r\n    }\r\n\r\n    isRunning() {\r\n        return this.engineIsRunning;\r\n    }\r\n    \r\n    async run() {\r\n        this.engineIsRunning = true;\r\n        let queues = this.algorithm();\r\n        if (!this.isMaze) {\r\n            await this.display(queues[\"visited\"], queues[\"path\"], this.displayFancy, \r\n                this.delay, this.isMaze, this.visitedColor, this.pathColor);\r\n        } else {\r\n            await this.display(queues[\"visited\"], queues[\"path\"], this.displayFancy, \r\n                this.delay, this.isMaze, this.visitedColor, this.pathColor);\r\n        }\r\n        this.engineIsRunning = false;\r\n    }\r\n    \r\n\r\n    async display(queue, path, displayFancy, delayMS, isMaze, visitedColor, pathColor) {\r\n        let baseOverLayDelayMS = 100;\r\n        let pathDelayMS = 20;\r\n        let r = visitedColor['r'];\r\n        let g = visitedColor['g'];\r\n        let b = visitedColor['b'];\r\n\r\n        function sleep(ms) {\r\n            return new Promise(resolve => setTimeout(resolve, ms));\r\n        }\r\n\r\n        async function overlapDisplay(box, r, g, b, catchUpDelay) {\r\n            /* rgb(64, 187, 224), rgb(56, 164, 197), rgb(48, 134, 160), rgb(48, 106, 160); */\r\n            if (r < 20 || g <= 50 || b <= 50 || hasBackgroundColor(box, pathColor)) {\r\n                return;\r\n            }\r\n            box.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;\r\n            await sleep(catchUpDelay + delayMS);\r\n            await overlapDisplay(box, r - 2, g - 6, b - 6, catchUpDelay);\r\n        }\r\n        \r\n\r\n        async function displayAndOverlap(isMaze) {\r\n            for (let i = 0; i < queue.length; i++) {\r\n                if (hasBackgroundColor(queue[i], \"white\")) {  // don't override green or red\r\n                    setBackgroundColor(queue[i], `rgb(${r}, ${g}, ${b})`);\r\n                    if (displayFancy && !isMaze) {\r\n                        setTimeout(function () { \r\n                            overlapDisplay(queue[i], r - 1, g - 3, b - 3, baseOverLayDelayMS); \r\n                        }, 500);\r\n                    }\r\n                }\r\n                await sleep(delayMS);\r\n            }\r\n        }\r\n\r\n        await displayAndOverlap(isMaze);\r\n\r\n        console.log(path);\r\n\r\n        for (let i = 0; i < path.length; i++) {\r\n            if (hasBackgroundColor(path[i], \"green\") || hasBackgroundColor(path[i], \"red\")) {\r\n                continue;\r\n            }\r\n            setBackgroundColor(path[i], pathColor);\r\n            await sleep(pathDelayMS); // Change seconds here to debug path\r\n        }\r\n        await sleep(delayMS + 1000 + baseOverLayDelayMS);\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function Dijkstras(startRow, startCol, endRow, endCol, orientationList) {\r\n    return DijkstrasRun(startRow, startCol, endRow, endCol, orientationListToJson(orientationList))\r\n}\r\n\r\nexport function A_star(startRow, startCol, endRow, endCol, orientationList) {\r\n    return A_star_run(startRow, startCol, endRow, endCol, orientationListToJson(orientationList));\r\n}\r\n\r\n\r\nexport function DFS(startRow, startCol, endRow, endCol, orientationList) {\r\n    return DFSRun(startRow, startCol, endRow, endCol, orientationListToJson(orientationList));\r\n}\r\n\r\n\r\nexport function BFS(startRow, startCol, endRow, endCol, orientationList) {\r\n    return BFSRun(startRow, startCol, endRow, endCol, orientationListToJson(orientationList));\r\n}\r\n\r\nexport function Greedy(startRow, startCol, endRow, endCol, orientationList) {\r\n    return GreedyRun(startRow, startCol, endRow, endCol, orientationListToJson(orientationList));\r\n}\r\n\r\nexport function blankMaze(startRow, startCol, endRow, endCol, orientationList) {\r\n    return runBlankMaze([startRow, startCol], [endRow, endCol]);\r\n}\r\n\r\nexport function recursiveBacktrack(startRow, startCol, endRow, endCol, orientationList) {\r\n    return runRecursiveBacktrack(startRow, startCol);\r\n}\r\n\r\nexport function randomPrims(startRow, startCol, endRow, endCol, orientationList) {\r\n    return runRandomPrims(startRow, startCol, endRow, endCol, orientationList);\r\n}\r\n\r\nexport function inverseRandomPrims(startRow, startCol, endRow, endCol, orientationList) {\r\n    return runRandomInversePrims(startRow, startCol, endRow, endCol, orientationList);\r\n}","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nconst Button = ( { id, color, text, onClick } ) => {\r\n    return (\r\n        <button id={id} style={{backgroundColor: color}} className='btn' \r\n            onClick={onClick}>{text}</button>\r\n    )\r\n}\r\n\r\nButton.defaultProps = {\r\n    color: 'black', \r\n    text: 'Button',\r\n    onClick: () => console.log('nothing happened'),\r\n}\r\n\r\nButton.propTypes = {\r\n    color: PropTypes.string,\r\n    text: PropTypes.string,\r\n    onClick: PropTypes.func\r\n}\r\n\r\nexport default Button\r\n","import {React, useState} from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\nconst CheckBox = ({ text, id, handleCheck }) => {\r\n\r\n    var [isChecked, toggleCheck] = useState(false);\r\n\r\n    toggleCheck = () => {\r\n        isChecked = !isChecked;\r\n    }\r\n\r\n    const handleCheckClick = (evt) => {\r\n        toggleCheck();\r\n        handleCheck(isChecked);\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <input id={id} className=\"checkbox\" type=\"checkbox\" text={text} \r\n                onChange={ (evt) => handleCheckClick(evt) }/> \r\n            <label for={id}>{text}</label>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default CheckBox;\r\n","import React from 'react';\r\nimport Button from './Button';\r\nimport CheckBox from './CheckBox';\r\n\r\nconst Controls = ({blueClick, redClick, greenClick, checkClick}) => {\r\n    return (\r\n        <span className=\"span-control\">\r\n            {/* <Button color='purple' text=\"Change Start\"/> \r\n            <Button color='purple' text=\"Change End\"/> */}  {/* To be deployed later*/}\r\n            <Button id=\"blue-control\" color='blue' text=\"Clear Display\" onClick={ blueClick } />\r\n            <Button id=\"red-control\" color='red' text=\"Clear All\" onClick={ redClick } />\r\n            <Button id=\"green-control\" color='green' text=\"Run\" onClick={ greenClick } />\r\n            <CheckBox id=\"show-display\" text=\"Fancy Graphics (may reduce performance)\"\r\n                handleCheck={ checkClick } />\r\n        </span>\r\n    )\r\n}\r\n\r\nexport default Controls\r\n","import {React, useState, useEffect} from 'react';\r\nimport {AlgorithmSelect, Select} from './Select';\r\nimport Orientations from './Orientations';\r\nimport {Dijkstras, DFS, BFS, A_star, Greedy } from '../Engine';\r\nimport { FaTimes } from 'react-icons/fa';\r\nimport Controls from './Controls';\r\nimport Button from './Button'\r\nimport { blankMaze, recursiveBacktrack, randomPrims, inverseRandomPrims } from '../Engine';\r\n\r\nexport const startPos = [10, 10];\r\nexport const endPos = [10, 45];\r\nexport const startingIcon = <FaTimes style={{color: 'red', cursor: 'pointer'}}/>\r\n\r\n\r\nconst nameToAlgs = {\r\n    \"DI\": Dijkstras,\r\n    \"DFS\": DFS,\r\n    \"BFS\": BFS,\r\n    \"A*\": A_star,\r\n    \"GREEDY\": Greedy\r\n  }\r\n\r\nexport const defaultOrientation = ['N', 'E', 'S', 'W'];\r\n\r\nconst speedToDelayMS = {\r\n    \"Fast\": 0,\r\n    \"Normal\": 20,\r\n    \"Slow\": 100,\r\n    \"Step-By-Step\": 1000\r\n}\r\n\r\nconst nameToMaze = {\r\n    \"Blank Board\": blankMaze,\r\n    \"Recursive Backtrack\": recursiveBacktrack,\r\n    \"Random Prim's\": randomPrims,\r\n    \"Inverse Random Prim's\": inverseRandomPrims\r\n}\r\n\r\nconst Settings = ({ blueFunc, redFunc, greenFunc }) => {\r\n\r\n    var [selectedAlg, setSelectedAlg] = useState('DI'); \r\n                                           // TODO: get the first option instead, \r\n                                           // needs to wait after construction\r\n\r\n    var [orientationList, setOrientation] = useState(defaultOrientation);\r\n\r\n    var [willDisplayFancy, toggleFancy] = useState(false);\r\n\r\n    var [speed, setSpeed] = useState(\"Fast\");\r\n\r\n    var [maze, setMaze] = useState(\"Blank Board\");\r\n\r\n    setSelectedAlg = (alg) => {\r\n        selectedAlg = alg;\r\n    }\r\n\r\n    setOrientation = (evt, number) => {\r\n        let index = parseInt(number);\r\n        orientationList[index - 1] = evt.target.value;\r\n    }\r\n\r\n    toggleFancy = (boxChecked) => {\r\n        willDisplayFancy = boxChecked;\r\n    }\r\n\r\n\r\n    setSpeed = (evt) => {\r\n        speed = evt.target.value;\r\n    }\r\n\r\n    setMaze = (evt) => {\r\n        maze = evt.target.value;\r\n    }\r\n\r\n    const getSelectedAlg = () => {\r\n        return nameToAlgs[selectedAlg];\r\n    }\r\n\r\n    const getSelectedMazeAlg = () => {\r\n        return nameToMaze[maze];\r\n    }\r\n\r\n    function handleOnClickGenMaze() {\r\n        greenFunc(getSelectedMazeAlg(), true, startPos[0], startPos[1], \r\n            endPos[0], endPos[1], orientationList, false, 0);\r\n    }\r\n\r\n    const handleClearAll = () => {\r\n        redFunc();\r\n    }\r\n\r\n    const handleClearDisplay = () => {\r\n        blueFunc();\r\n    }\r\n\r\n    function handleOnClickRun() {\r\n        // TODO: if not already running:\r\n        greenFunc(getSelectedAlg(), false, startPos[0], startPos[1], \r\n            endPos[0], endPos[1], orientationList, willDisplayFancy, speedToDelayMS[speed]);\r\n    }\r\n\r\n    function handleOnCheck(boxChecked) {\r\n        toggleFancy(boxChecked);\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <div className=\"settings\">\r\n                <br></br>\r\n                <span className=\"dir-text\">\r\n                    Orientation tie-break rule:\r\n                </span>\r\n                <Orientations onChange={ setOrientation }/>\r\n                <br></br>\r\n                <span className=\"note\"> Note: NESW will be chosen if \r\n                invalid orientation sequence is selected</span>\r\n                <br></br>\r\n                <span className=\"dir-text\">\r\n                    Select a Pathfind algorithm: \r\n                </span>\r\n                <AlgorithmSelect onChange={ setSelectedAlg } />\r\n                <br></br>\r\n                <span className=\"dir-text\">\r\n                    Select a maze generation algorithm: \r\n                </span>\r\n                <Select className=\"maze-slct\" color=\"black\" numOptions={4} \r\n                    values={[\"Blank Board\", \"Recursive Backtrack\", \"Random Prim's\", \"Inverse Random Prim's\"]}  // TODO: ADD PRIMS BACK\r\n                    texts={[\"Blank Board\", \"Recursive Backtrack\", \"Random Prim's\", \"Inverse Random Prim's\"]} onChange={ setMaze } />\r\n                <Button id=\"maze-btn\" color=\"green\" text=\"Generate\" onClick={ handleOnClickGenMaze } />\r\n                <br></br>\r\n                <span className=\"dir-text\">\r\n                    Select an algorithm display speed: \r\n                </span>\r\n                <Select className=\"speed-slct\" color=\"black\" numOptions={4} \r\n                    values={[\"Fast\", \"Normal\", \"Slow\", \"Step-By-Step\"]} \r\n                    texts={[\"Fast\", \"Normal\", \"Slow\", \"Step-By-Step\"]} onChange={ setSpeed } />\r\n                <br></br>\r\n                <hr></hr>\r\n            </div>\r\n            <br></br>\r\n            <div className='playground'>\r\n                <span className=\"dir-text\">\r\n                    Drag your mouse on the tiles to create walls. Have Fun!\r\n                </span>\r\n                <Controls \r\n                    blueClick={ handleClearDisplay }\r\n                    redClick={ handleClearAll }  \r\n                    greenClick={ handleOnClickRun } \r\n                    checkClick={ handleOnCheck }\r\n                />\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\n//TODO: {algorithm} must be function\r\n\r\nexport default Settings;\r\n","import { makeAllWhite, setBackgroundColor } from '../utils';\r\nimport {maxRow, maxCol} from '../components/Board';\r\n\r\nexport default function runBlankMaze(startPos, endPos) {\r\n    makeAllWhite();\r\n    return {\"visited\": [], \"path\": []};\r\n}","import {getAdjacent, getRowFromId, getColFromId, getElementByPos,\r\n    getAllBoxes, shuffle, orientationListToJson, nextToVisited, getFrontier, randNum, getBoxBetween, makeAllWhite} from '../utils';\r\nimport { maxRow, maxCol } from '../components/Board';\r\nimport { defaultOrientation } from '../components/Settings';\r\n\r\n\r\nexport default function runRandomInversePrims(startRow, startCol) {\r\n    makeAllWhite();\r\n\r\n    var orientations = defaultOrientation.splice();\r\n    let whiteVisited = [getElementByPos(startRow, startCol)];\r\n    let frontiers = [getElementByPos(startRow, startCol)];\r\n    while (frontiers.length > 0) {\r\n        shuffle(orientations);\r\n        let index = randNum(0, frontiers.length);\r\n        let currBox = frontiers[index];\r\n        frontiers.splice(index, 1)\r\n        startRow = getRowFromId(currBox.id);\r\n        startCol = getColFromId(currBox.id);\r\n        let adjsFrontiers = getFrontier(startRow, startCol, whiteVisited, \r\n            orientationListToJson(orientations));\r\n        if (adjsFrontiers.length > 0) {\r\n            let frontierBox = adjsFrontiers[0];\r\n            let betweenBox = getBoxBetween(frontierBox, currBox);\r\n            whiteVisited.push(currBox);\r\n            whiteVisited.push(betweenBox);\r\n            whiteVisited.push(frontierBox);\r\n            adjsFrontiers.forEach((adj) => {\r\n                frontiers.push(adj);\r\n            });\r\n        }\r\n    }\r\n    return {\"visited\": whiteVisited, \"path\": []};\r\n}\r\n\r\n\r\nfunction getAllBoxHorizontal() {\r\n    let lst = []\r\n    for (let row = 0; row <= maxRow; row++) {\r\n        for (let col = 0; col <= maxCol; col++) {\r\n            lst.push(document.getElementById(`${row}-${col}`));\r\n        }\r\n    }\r\n    return lst;\r\n}","import {React, useState, useEffect} from 'react';\r\nimport Header from './components/Header';\r\nimport Settings from './components/Settings';\r\nimport Board from './components/Board';\r\nimport {Engine} from './Engine';\r\nimport { FaTimes } from 'react-icons/fa';\r\nimport {maxRow, maxCol} from './components/Board';\r\nimport {hasBackgroundColor, setBackgroundColor} from './utils';\r\nexport var startPos = [10, 10];\r\nexport var endPos = [10, 45];\r\nexport var startingIcon = <FaTimes style={{color: 'red', cursor: 'pointer'}}/>\r\n\r\n\r\nfunction App() {\r\n\r\n\r\n  var [engine, setEngine] = useState(null);\r\n\r\n    /* will only be called after initial rendering; initalizes engine */\r\n    useEffect(() => {\r\n        setEngine(new Engine(null, 0, 0, 0, 0, [], false, 0));\r\n    }, []);\r\n\r\n\r\n    setEngine = (newEngine) => {\r\n      engine = newEngine;\r\n    }\r\n\r\n  const clearAll = () => {\r\n    if (!engine.isRunning()) {\r\n      for (let row = 0; row <= maxRow; row++) {\r\n        for (let col = 0; col <= maxCol; col++) {\r\n          let box = document.getElementById(`${row}-${col}`);\r\n          if (row === startPos[0] && col === startPos[1]) {\r\n              setBackgroundColor(box, \"green\");\r\n          } else if (row === endPos[0] && col === endPos[1]) {\r\n              setBackgroundColor(box, \"red\");\r\n          } else {\r\n              setBackgroundColor(box, \"white\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const clearDisplay = () => {\r\n    if (!engine.isRunning()) {\r\n      for (let row = 0; row <= maxRow; row++) {\r\n        for (let col = 0; col <= maxCol; col++) {\r\n          let box = document.getElementById(`${row}-${col}`);\r\n          if (row === startPos[0] && col === startPos[1]) {\r\n              setBackgroundColor(box, \"green\");\r\n          } else if (row === endPos[0] && col === endPos[1]) {\r\n              setBackgroundColor(box, \"red\");\r\n          } else if (hasBackgroundColor(box, \"black\")) {\r\n              continue;\r\n          } else {\r\n              setBackgroundColor(box, \"white\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async function runEngine(alg, isMaze, startRow, startCol, endRow, endCol, oriList, willDisplayFancy, delay) {\r\n    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });\r\n    if (!engine.isRunning()) {\r\n      setBackgroundColor(document.getElementById('green-control'), \"gray\");\r\n      setEngine(new Engine(alg, isMaze, startRow, startCol, \r\n                endRow, endCol, oriList, willDisplayFancy, delay));\r\n      await engine.run();\r\n      setBackgroundColor(document.getElementById('green-control'), \"green\");\r\n    }\r\n  }\r\n\r\n  const canDraw = () => {\r\n    return !engine.isRunning();\r\n  }\r\n\r\n  return ( // Has to return SINGLE element\r\n    <div className=\"App\">\r\n      <Header/>\r\n      <hr></hr>\r\n      <Settings blueFunc={ clearDisplay } redFunc={ clearAll } greenFunc={ runEngine } />\r\n      <Board canDrawOn={canDraw} />\r\n      <br></br>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}